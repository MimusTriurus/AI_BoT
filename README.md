## Precondition
- Install MAPF lib: https://w9-pathfinding.readthedocs.io/stable/installation.html#for-development-purposes

## Prompt

# 0
    Пошаговая тактика на гексогональном поле. Аналог MassiveAssault 2.
    Необходимо реализовать механизм транспортов.
    Дано: 
    - боевые юниты:
      Юнит:
      - дальность атаки
      - дальность движения
      - урон
    - набор целей:
      Цель:
      - здоровье
      - ценность
    - транспорты:
      Транспорт:
      - максимальное количество юнитов внутри
      - дальность движения
    
    Необходимо:
    - определить какие юниты могут быть доставлены до целей при помощи траспорта, чтобы нанести максимальный урон\уничтожить цель
      - построить маршрут для транспорта, чтобы он приближался вплотную к нашим юнитам для погрузки
      - определял оптимальную позицию для выгрузки юнитов
      - строил маршрут к этой позиции

    Дополнительно:
        - Транспорт двигается к юнитам для их погрузки. 
        - При посадке и высадке юнита из транспорта, юнит тратит одно очко передвижения
    
    Допустим У нас есть в распоряжении библиотека постоения путей (A*) на гексогональном поле.
    
    Предложи алгоритм реализуцющий эту функцию. Пока в виде высокоуровнего описания

##    MDVRP (Multi-Depot VRP)
# 1
    Реализуй алгоритм на python использую следующие структуры данных
    # Гексагональное поле. -1 - непроходимый гекс
    map = [
        # 0   1   2   3   4   5   6
        [ 1,  1,  1,  1,  1,  1,  1],  # 0
        [ 1,  1,  1,  1,  1,  1,  1],  # 1
        [ 1,  1,  1,  1,  1,  1,  1],  # 2
        [ 1,  1,  1, -1, -1,  1, -1],  # 3
        [ 1,  1,  1, -1,  1,  1,  1],  # 4
        [ 1,  1,  1,  1,  1,  1,  1],  # 5
        [ 1,  1,  1,  1,  1,  1,  1],  # 6
    ]
    units = [
        {START_KEY: (0, 0), MOVE_RANGE_KEY: max_move_range, ATTACK_RANGE_KEY: 1, DAMAGE_KEY: 1},  # 1
    ]
    
    targets = [
        {POS_KEY: (1, 5), VALUE_KEY: 0.1, HP_KEY: 3},
    ]
    # объект описывающий гексогональное поле
    # примеры:
    # - grid.calculate_cost(path)
    # - grid.get_neighbors((0,0), include_self=False) возвращает список Tuple((0,0), 1) где (0,0) координаты гекса, а 1 - стоимость передвижения (пока можешь игнорировать)
    # - grid.has_obstacle((0,0))
    grid = HexGrid(weights=weights, edge_collision=True, layout=HexLayout.odd_q)

    # path solver - AStar
    # примеры
    # - path = pf.find_path((0,1), (0,5))
    pf = AStar(grid)

# 3
учти, чтл grid.get_neighbors() возвращает список Tuple((0,0), 1) где (0,0) координаты гекса, а 1 - стоимость передвижения (пока можешь игнорировать) 

#  Допустим мы сформировали множество вариантов планов доставки юнитов к целям (TransportPlan).
Теперь нам надо выполнить оптимизацию (аукцион)
1. Насать метод который оценивает эфективность\полезность этого плана.
Эффективность\полезность должна определяться исходя из того, какой урон будет нанесен цели, ценности цели и был ли оверхед по урону по цели
2. Реализовать Iterative Improvement:
Раздать задачи методом Аукциона (см. пункт 3).
Проверить всех "безработных" транспортов.
Попытаться "отобрать" пассажира у занятого транспорта, если это увеличит суммарную полезность команды.

unit = {
    ID_KEY: 'u_id',
    POS_KEY: (0, 0),
    MOVE_RANGE_KEY: 1,
    DAMAGE_KEY: 1,
    ATTACK_RANGE_KEY: 1,
    HP_KEY: 4,
    VALUE_KEY: 10,
    # для транспортов
    CAPACITY_KEY: 0,
}
class TransportPlan:
    def __init__(
            self,
            transport: dict,
            target: dict,
            passengers: List[dict],
            path: List[Tuple[int, int]],
            grid: HexGrid,
            pf: AStar
    ):
        self.transport: dict = transport
        self.target: dict = target
        self.passengers: List[dict] = passengers
        self.path: Dict[str, Tuple[int, int]] = path
        self.grid: HexGrid = grid
        self.pf: AStar = pf
        self.meeting_points: Dict[str, Tuple[int, int]] = self.calculate_meeting_points()
        self.delivery_path: List[Tuple[int, int]] = self.calculate_delivery_path()
        self.utility: float = self._calculate_utility()

Есть список с вариантами TransportPlan для нескольких транспортов и целей с разными вариантами path\target\passengers и т.д.
Необходимо сформировать оптимимальный список TransportPlan максимизирующий utility
Контекст: пошаговая тактика на гексогональном поле. Транспортные операции.
Аукцион задач
Транспорт может содержать несколько юнитов (допустим 2). Несколько транспортов могут атаковать одну цель. Один и тот же юнит не может в итоге присутствовать в разных планах.
Планов может быть больше 1000. Желательно реализовать не жадный алгоритм