## Precondition
- Install MAPF lib: https://w9-pathfinding.readthedocs.io/stable/installation.html#for-development-purposes

## Prompt

# 0
    Пошаговая тактика на гексогональном поле. Аналог MassiveAssault 2.
    Необходимо реализовать механизм транспортов.
    Дано: 
    - боевые юниты:
      Юнит:
      - дальность атаки
      - дальность движения
      - урон
    - набор целей:
      Цель:
      - здоровье
      - ценность
    - транспорты:
      Транспорт:
      - максимальное количество юнитов внутри
      - дальность движения
    
    Необходимо:
    - определить какие юниты могут быть доставлены до целей при помощи траспорта, чтобы нанести максимальный урон\уничтожить цель
      - построить маршрут для транспорта, чтобы он приближался вплотную к нашим юнитам для погрузки
      - определял оптимальную позицию для выгрузки юнитов
      - строил маршрут к этой позиции

    Дополнительно:
        - юнит и транспорт могут двигаться навстречу друг другу для экономии ходов
        - Транспорт\юнит не тратит очки передвижения на погрузку если они стоят вплонтую
    
    Допустим У нас есть в распоряжении библиотека постоения путей (A* и различные варианты MAPF)
    
    Предложи алгоритм реализуцющий эту функцию. Пока в виде высокоуровнего описания


# 1
    Реализуй алгоритм на python использую следующие структуры данных
    # Гексагональное поле. -1 - непроходимый гекс
    map = [
        # 0   1   2   3   4   5   6
        [ 1,  1,  1,  1,  1,  1,  1],  # 0
        [ 1,  1,  1,  1,  1,  1,  1],  # 1
        [ 1,  1,  1,  1,  1,  1,  1],  # 2
        [ 1,  1,  1, -1, -1,  1, -1],  # 3
        [ 1,  1,  1, -1,  1,  1,  1],  # 4
        [ 1,  1,  1,  1,  1,  1,  1],  # 5
        [ 1,  1,  1,  1,  1,  1,  1],  # 6
    ]
    units = [
        {START_KEY: (0, 0), MOVE_RANGE_KEY: max_move_range, ATTACK_RANGE_KEY: 1, DAMAGE_KEY: 1},  # 1
    ]
    
    targets = [
        {POS_KEY: (1, 5), VALUE_KEY: 0.1, HP_KEY: 3},
    ]
    # объекс описывающий гексогональное поле
    # примеры:
    # - grid.calculate_cost([(0,0), (0,5)])
    # - grid.get_neighbors((0,0), include_self=False) возвращает список Tuple((0,0), 1) где (0,0) координаты гекса, а 1 - стоимость передвижения (пока можешь игнорировать)
    # - grid.has_obstacle((0,0))
    grid = HexGrid(weights=weights, edge_collision=True, layout=HexLayout.odd_q)
    # таблица резервирования ходов для mapf
    rt = ReservationTable(grid)
    # mapf solver - CBS 
    # примеры:
    # - paths = self.finder.mapf([(0,0)], [(0,5)], reservation_table=self.rt, max_length=max_unit_steps)
    mapf = CBS(grid)
    # path solver - AStar
    # примеры
    # - pf.find_path((0,1), (0,5))
    pf = AStar(grid)

# 3
учти, чтл grid.get_neighbors() возвращает список Tuple((0,0), 1) где (0,0) координаты гекса, а 1 - стоимость передвижения (пока можешь игнорировать) 