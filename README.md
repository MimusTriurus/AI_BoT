## Precondition
- Install MAPF lib: https://w9-pathfinding.readthedocs.io/stable/installation.html#for-development-purposes

## Prompt

# 0
    Пошаговая тактика на гексогональном поле. Аналог MassiveAssault 2.
    Необходимо реализовать механизм транспортов.
    Дано: 
    - боевые юниты:
      Юнит:
      - дальность атаки
      - дальность движения
      - урон
    - набор целей:
      Цель:
      - здоровье
      - ценность
    - транспорты:
      Транспорт:
      - максимальное количество юнитов внутри
      - дальность движения
    
    Необходимо:
    - определить какие юниты могут быть доставлены до целей при помощи траспорта, чтобы нанести максимальный урон\уничтожить цель
      - построить маршрут для транспорта, чтобы он приближался вплотную к нашим юнитам для погрузки
      - определял оптимальную позицию для выгрузки юнитов
      - строил маршрут к этой позиции

    Дополнительно:
        - Транспорт двигается к юнитам для их погрузки. 
        - При посадке и высадке юнита из транспорта, юнит тратит одно очко передвижения
    
    Допустим У нас есть в распоряжении библиотека постоения путей (A*) на гексогональном поле.
    
    Предложи алгоритм реализуцющий эту функцию. Пока в виде высокоуровнего описания

##    MDVRP (Multi-Depot VRP)
# 1
    Реализуй алгоритм на python использую следующие структуры данных
    # Гексагональное поле. -1 - непроходимый гекс
    map = [
        # 0   1   2   3   4   5   6
        [ 1,  1,  1,  1,  1,  1,  1],  # 0
        [ 1,  1,  1,  1,  1,  1,  1],  # 1
        [ 1,  1,  1,  1,  1,  1,  1],  # 2
        [ 1,  1,  1, -1, -1,  1, -1],  # 3
        [ 1,  1,  1, -1,  1,  1,  1],  # 4
        [ 1,  1,  1,  1,  1,  1,  1],  # 5
        [ 1,  1,  1,  1,  1,  1,  1],  # 6
    ]
    units = [
        {START_KEY: (0, 0), MOVE_RANGE_KEY: max_move_range, ATTACK_RANGE_KEY: 1, DAMAGE_KEY: 1},  # 1
    ]
    
    targets = [
        {POS_KEY: (1, 5), VALUE_KEY: 0.1, HP_KEY: 3},
    ]
    # объект описывающий гексогональное поле
    # примеры:
    # - grid.calculate_cost(path)
    # - grid.get_neighbors((0,0), include_self=False) возвращает список Tuple((0,0), 1) где (0,0) координаты гекса, а 1 - стоимость передвижения (пока можешь игнорировать)
    # - grid.has_obstacle((0,0))
    grid = HexGrid(weights=weights, edge_collision=True, layout=HexLayout.odd_q)

    # path solver - AStar
    # примеры
    # - path = pf.find_path((0,1), (0,5))
    pf = AStar(grid)

# 3
учти, чтл grid.get_neighbors() возвращает список Tuple((0,0), 1) где (0,0) координаты гекса, а 1 - стоимость передвижения (пока можешь игнорировать) 

#  Допустим мы сформировали множество вариантов планов доставки юнитов к целям (TransportPlan).
Теперь нам надо выполнить оптимизацию (аукцион)
1. Насать метод который оценивает эфективность\полезность этого плана.
Эффективность\полезность должна определяться исходя из того, какой урон будет нанесен цели, ценности цели и был ли оверхед по урону по цели
2. Реализовать Iterative Improvement:
Раздать задачи методом Аукциона (см. пункт 3).
Проверить всех "безработных" транспортов.
Попытаться "отобрать" пассажира у занятого транспорта, если это увеличит суммарную полезность команды.

def make_unit(u_id, pos, unit_type: UnitType):
    unit = {
        ID_KEY: u_id,
        POS_KEY: pos,
        MOVE_RANGE_KEY: unit_data[unit_type][0],
        DAMAGE_KEY: unit_data[unit_type][1],
        ATTACK_RANGE_KEY: unit_data[unit_type][2],
        HP_KEY: unit_data[unit_type][3],
        VALUE_KEY: unit_data[unit_type][4],
        CAPACITY_KEY: unit_data[unit_type][5],
    }
    return unit


class TransportPlan:
    def __init__(
            self,
            transport: dict,
            target: dict,
            passengers: List[dict],
            path: List[Tuple[int, int]]
    ):
        self.transport: dict = transport
        self.target: dict = target
        self.passengers: List[dict] = passengers
        self.path = path