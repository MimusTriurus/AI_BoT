## Precondition
- Install MAPF lib: https://w9-pathfinding.readthedocs.io/stable/installation.html#for-development-purposes

## Prompt

# 0
    Пошаговая тактика на гексогональном поле. Аналог MassiveAssault 2.
    Необходимо реализовать механизм транспортов.
    Дано: 
    - боевые юниты:
      Юнит:
      - дальность атаки
      - дальность движения
      - урон
    - набор целей:
      Цель:
      - здоровье
      - ценность
    - транспорты:
      Транспорт:
      - максимальное количество юнитов внутри
      - дальность движения
    
    Необходимо:
    - определить какие юниты могут быть доставлены до целей при помощи траспорта, чтобы нанести максимальный урон\уничтожить цель
      - построить маршрут для транспорта, чтобы он приближался вплотную к нашим юнитам для погрузки
      - определял оптимальную позицию для выгрузки юнитов
      - строил маршрут к этой позиции

    Дополнительно:
        - Транспорт двигается к юнитам для их погрузки. 
        - При посадке и высадке юнита из транспорта, юнит тратит одно очко передвижения
    
    Допустим У нас есть в распоряжении библиотека постоения путей (A*) на гексогональном поле.
    
    Предложи алгоритм реализуцющий эту функцию. Пока в виде высокоуровнего описания

##    MDVRP (Multi-Depot VRP)
# 1
    Реализуй алгоритм на python использую следующие структуры данных
    # Гексагональное поле. -1 - непроходимый гекс
    map = [
        # 0   1   2   3   4   5   6
        [ 1,  1,  1,  1,  1,  1,  1],  # 0
        [ 1,  1,  1,  1,  1,  1,  1],  # 1
        [ 1,  1,  1,  1,  1,  1,  1],  # 2
        [ 1,  1,  1, -1, -1,  1, -1],  # 3
        [ 1,  1,  1, -1,  1,  1,  1],  # 4
        [ 1,  1,  1,  1,  1,  1,  1],  # 5
        [ 1,  1,  1,  1,  1,  1,  1],  # 6
    ]
    units = [
        {START_KEY: (0, 0), MOVE_RANGE_KEY: max_move_range, ATTACK_RANGE_KEY: 1, DAMAGE_KEY: 1},  # 1
    ]
    
    targets = [
        {POS_KEY: (1, 5), VALUE_KEY: 0.1, HP_KEY: 3},
    ]
    # объект описывающий гексогональное поле
    # примеры:
    # - grid.calculate_cost(path)
    # - grid.get_neighbors((0,0), include_self=False) возвращает список Tuple((0,0), 1) где (0,0) координаты гекса, а 1 - стоимость передвижения (пока можешь игнорировать)
    # - grid.has_obstacle((0,0))
    grid = HexGrid(weights=weights, edge_collision=True, layout=HexLayout.odd_q)

    # path solver - AStar
    # примеры
    # - path = pf.find_path((0,1), (0,5))
    pf = AStar(grid)

# 3
учти, чтл grid.get_neighbors() возвращает список Tuple((0,0), 1) где (0,0) координаты гекса, а 1 - стоимость передвижения (пока можешь игнорировать) 

#  Допустим мы сформировали множество вариантов планов доставки юнитов к целям (TransportPlan).
Теперь нам надо выполнить оптимизацию (аукцион)
1. Насать метод который оценивает эфективность\полезность этого плана.
Эффективность\полезность должна определяться исходя из того, какой урон будет нанесен цели, ценности цели и был ли оверхед по урону по цели
2. Реализовать Iterative Improvement:
Раздать задачи методом Аукциона (см. пункт 3).
Проверить всех "безработных" транспортов.
Попытаться "отобрать" пассажира у занятого транспорта, если это увеличит суммарную полезность команды.

unit = {
    ID_KEY: 'u_id',
    POS_KEY: (0, 0),
    MOVE_RANGE_KEY: 1,
    DAMAGE_KEY: 1,
    ATTACK_RANGE_KEY: 1,
    HP_KEY: 4,
    VALUE_KEY: 10,
    # для транспортов
    CAPACITY_KEY: 0,
}
class TransportPlan:
    def __init__(
            self,
            transport: dict,
            target: dict,
            passengers: List[dict],
            path: List[Tuple[int, int]],
            grid: HexGrid,
            pf: AStar
    ):
        self.transport: dict = transport
        self.target: dict = target
        self.passengers: List[dict] = passengers
        self.path: Dict[str, Tuple[int, int]] = path
        self.grid: HexGrid = grid
        self.pf: AStar = pf
        self.meeting_points: Dict[str, Tuple[int, int]] = self.calculate_meeting_points()
        self.delivery_path: List[Tuple[int, int]] = self.calculate_delivery_path()
        self.utility: float = self._calculate_utility()

Есть список с вариантами TransportPlan для нескольких транспортов и целей с разными вариантами path\target\passengers и т.д.
Необходимо сформировать оптимимальный список TransportPlan максимизирующий utility
Контекст: пошаговая тактика на гексогональном поле. Транспортные операции.
Аукцион задач
Транспорт может содержать несколько юнитов (допустим 2). Несколько транспортов могут атаковать одну цель. Один и тот же юнит не может в итоге присутствовать в разных планах.
Планов может быть больше 1000. Желательно реализовать не жадный алгоритм

# Доработка TransportPlan. Разгрузка юнитов.
Допустим мы получили путь загрузки юнитов и путь доставки юнитов к цели в точку разгрузки.
'''
# юниты в транспорте в порядке их загрузки, длинна маршрута, путь к точке выгрузки
best_order, cost, path = solve_transport_mission(
    transport_pos=transport_pos,
    transport_mp=transport_mp,
    passengers=units_pos,
    drop_zone=position_2_unload,
    enemy_positions=en_units_storage.get_units_pos(),
    grid=grid,
    pf=pf
)
'''

Теперь для каждого юнита в транспорте надо расчитать возможные точки выгрузки.
Таким образом у нас должен создаваться TransportPlan для каждого транспорта, для каждого варианта набора юнитов атакующих каждую цель со всеми возможными вариантами выгрузки к цели.
Чтобы потом решить задачу комбинаторной оптимизации и выбрать лучший вариант доставки юнитов транспортами и их выгрузки для атаки цели

## Описание

1. Кластеризация юнитов
- K-Mean++ + soft-clustering - делим юнитов на группы по степени близости + один и тот же юнит может входить в разные кластера
2. Генерируем все возможные наборы пассажиров (с учетом емкости траспорта) для каждого кластера
   3. Создаем все возможные TransportMission для связки Транспорт -> Набор пассажиров -> Цель
   3.1 Определяем оптимальную точку выгрузки к цели для набора юнитов
       - получаем позиции вокруг цели в радиусе атаки юнита с максимальной дистанцией атаки (движение + радиус)
       - находим общее пересечение позиций из которых все юниты могут атаковать
       - если нет общих позиций, берем позицию для юнита с наименьшей дальностью
   3.2 Для каждой возможной позиции атаки по цели определенным набором юнитов считаем все возможные последовательности загрузки юнитов (брут форсим разные варианты решая задачу коммиваяжора). 
       - отбрасываем варианты длинна пути которых превышает лимит очков передвижения транспорта
       - получаем маршрут от стартовой позиции к точкам погрузки юнитов и далее к цели, стоимость маршрута и набор точек погрузки
       - исходим из допущения, что юниты стоят на месте, а транспорт сам двигается в точку погрузки
   3.3 Для каждой возможной позиции атаки по цели определенным набором юнитов (загруженных в определенном порядке) при помощи определенного транспорта считаем utility TransportMission
       - utility учитывает: 
           - урон цели, 
           - стоимость доставки юнитов ПОСЛЕ их загрузки,
           - оверхед урона, 
           - ценность цели, 
           - бонус за убийство цели, 
           - может ли юнит атаковать цель без транспорта

           Возможно стоит учитывать коэфицент загрузки транспорта и кол-во не израсходованных очков движения

       Чтобы снизить кол-во вариантов TransportMission стоит ввести threshold для utility
4. Ищем оптимальное сочетание планов TransportMission юнитов для каждого транспорта (выполняем комбинаторную оптимизацию)
    Два подхода:
    - Аукцион задач (АЗ) + LocalSearch (Немного жадный метод, но быстрый и близкий к оптимальному)
    - Branch and Bound (БнБ) (высокая вероятность найти идеальное сочетание планов, но метод достаточно тяжелый. Хорошо параллелится на CPU. После 500 TransportMission рост вычислений растет экспоненциально)
    Три сценария применения:
    - АЗ+LS и БнБ по отдельности (в зависимости от кол-ва TransportMission)
    - Сначала АЗ+LS сокращения вариантов а затем БнБ для проверки оптимальности